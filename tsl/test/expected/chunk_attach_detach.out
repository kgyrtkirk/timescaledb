\ir ../../../test/sql/include/test_utils.sql
-- This file and its contents are licensed under the Apache License 2.0.
-- Please see the included NOTICE for copyright information and
-- LICENSE-APACHE for a copy of the license.
CREATE OR REPLACE FUNCTION assert_true(
    val boolean
)
 RETURNS VOID LANGUAGE PLPGSQL IMMUTABLE AS
$BODY$
BEGIN
    IF val IS NOT TRUE THEN
        RAISE 'Assert failed';
    END IF;
END
$BODY$;
CREATE OR REPLACE FUNCTION assert_equal(
    val1 anyelement,
    val2 anyelement
)
 RETURNS VOID LANGUAGE PLPGSQL IMMUTABLE AS
$BODY$
BEGIN
    IF (val1 = val2) IS NOT TRUE THEN
        RAISE 'Assert failed: % = %',val1,val2;
    END IF;
END
$BODY$;
CREATE TABLE main_table AS
SELECT '2011-11-11 11:11:11'::timestamptz AS time, 'foo' AS device_id limit 0;
SELECT create_hypertable('main_table', 'time', chunk_time_interval => interval '12 hour', migrate_data => TRUE);
NOTICE:  adding not-null constraint to column "time"
    create_hypertable    
-------------------------
 (1,public,main_table,t)
(1 row)

ALTER TABLE main_table SET (
    timescaledb.compress,
    timescaledb.compress_segmentby = 'device_id',
    timescaledb.compress_orderby = '');
INSERT INTO main_table SELECT t, 'dev1'  FROM generate_series('2018-03-02 1:00'::TIMESTAMPTZ, '2018-03-05 3:00', '1 hour') t;
select show_chunks('main_table');
              show_chunks               
----------------------------------------
 _timescaledb_internal._hyper_1_1_chunk
 _timescaledb_internal._hyper_1_2_chunk
 _timescaledb_internal._hyper_1_3_chunk
 _timescaledb_internal._hyper_1_4_chunk
 _timescaledb_internal._hyper_1_5_chunk
 _timescaledb_internal._hyper_1_6_chunk
 _timescaledb_internal._hyper_1_7_chunk
(7 rows)

SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('main_table')
ORDER BY slices;
 chunk_id | hypertable_id |      schema_name      |    table_name    | relkind |                     slices                     
----------+---------------+-----------------------+------------------+---------+------------------------------------------------
        1 |             1 | _timescaledb_internal | _hyper_1_1_chunk | r       | {"time": [1519948800000000, 1519992000000000]}
        2 |             1 | _timescaledb_internal | _hyper_1_2_chunk | r       | {"time": [1519992000000000, 1520035200000000]}
        3 |             1 | _timescaledb_internal | _hyper_1_3_chunk | r       | {"time": [1520035200000000, 1520078400000000]}
        4 |             1 | _timescaledb_internal | _hyper_1_4_chunk | r       | {"time": [1520078400000000, 1520121600000000]}
        5 |             1 | _timescaledb_internal | _hyper_1_5_chunk | r       | {"time": [1520121600000000, 1520164800000000]}
        6 |             1 | _timescaledb_internal | _hyper_1_6_chunk | r       | {"time": [1520164800000000, 1520208000000000]}
        7 |             1 | _timescaledb_internal | _hyper_1_7_chunk | r       | {"time": [1520208000000000, 1520251200000000]}
(7 rows)

with t as (SELECT * FROM show_chunks('main_table') as t(ch) order by ch)
select (select ch from t limit 1 offset 2) as chunk, (select ch from t limit 1 offset 3) as chunk2 \gset
select * from _timescaledb_internal.show_chunk(:'chunk')
union all
select * from _timescaledb_internal.show_chunk(:'chunk2');
 chunk_id | hypertable_id |      schema_name      |    table_name    | relkind |                     slices                     
----------+---------------+-----------------------+------------------+---------+------------------------------------------------
        3 |             1 | _timescaledb_internal | _hyper_1_3_chunk | r       | {"time": [1520035200000000, 1520078400000000]}
        4 |             1 | _timescaledb_internal | _hyper_1_4_chunk | r       | {"time": [1520078400000000, 1520121600000000]}
(2 rows)

select assert_equal(count(1),12::bigint) from :chunk;
 assert_equal 
--------------
 
(1 row)

select assert_equal(count(1),12::bigint) from :chunk2;
 assert_equal 
--------------
 
(1 row)

select assert_equal(count(1),75::bigint) from main_table;
 assert_equal 
--------------
 
(1 row)

\d :chunk
            Table "_timescaledb_internal._hyper_1_3_chunk"
  Column   |           Type           | Collation | Nullable | Default 
-----------+--------------------------+-----------+----------+---------
 time      | timestamp with time zone |           | not null | 
 device_id | text                     |           |          | 
Indexes:
    "_hyper_1_3_chunk_main_table_time_idx" btree ("time" DESC)
Check constraints:
    "constraint_3" CHECK ("time" >= 'Fri Mar 02 16:00:00 2018 PST'::timestamp with time zone AND "time" < 'Sat Mar 03 04:00:00 2018 PST'::timestamp with time zone)
Inherits: main_table

-- reject detach if compressed
select compress_chunk(:'chunk'::regclass);
             compress_chunk             
----------------------------------------
 _timescaledb_internal._hyper_1_3_chunk
(1 row)

\set ON_ERROR_STOP 0
select _timescaledb_internal.chunk_detach(:'chunk'::regclass);
ERROR:  can't detach chunk "_hyper_1_3_chunk" because its compressed
\set ON_ERROR_STOP 1
select decompress_chunk(:'chunk'::regclass);
            decompress_chunk            
----------------------------------------
 _timescaledb_internal._hyper_1_3_chunk
(1 row)

-- reject if cagg is present
CREATE MATERIALIZED VIEW mat_m1(a, countb) WITH (timescaledb.continuous, timescaledb.materialized_only=true, timescaledb.finalized=false)
as select time_bucket('1 hour', time),device_id, count(1) from main_table group by time_bucket('1 hour', time), device_id WITH NO DATA;
\set ON_ERROR_STOP 0
select _timescaledb_internal.chunk_detach(:'chunk'::regclass);
ERROR:  can't detach chunk "_hyper_1_3_chunk" from hypertable which has continous aggregates
\set ON_ERROR_STOP 1
DROP MATERIALIZED VIEW mat_m1;
-- detach chunks
select _timescaledb_internal.chunk_detach(:'chunk'::regclass);
                  chunk_detach                  
------------------------------------------------
 {"time": [1520035200000000, 1520078400000000]}
(1 row)

select assert_equal(count(1),63::bigint) from main_table;
 assert_equal 
--------------
 
(1 row)

\d :chunk
            Table "_timescaledb_internal._hyper_1_3_chunk"
  Column   |           Type           | Collation | Nullable | Default 
-----------+--------------------------+-----------+----------+---------
 time      | timestamp with time zone |           | not null | 
 device_id | text                     |           |          | 

select _timescaledb_internal.chunk_detach(:'chunk2'::regclass);
                  chunk_detach                  
------------------------------------------------
 {"time": [1520078400000000, 1520121600000000]}
(1 row)

select assert_equal(count(1),51::bigint) from main_table;
 assert_equal 
--------------
 
(1 row)

-- create union chunk
create table n (like main_table);
\d n
                           Table "public.n"
  Column   |           Type           | Collation | Nullable | Default 
-----------+--------------------------+-----------+----------+---------
 time      | timestamp with time zone |           | not null | 
 device_id | text                     |           |          | 

insert into n 
select * from :chunk union all select * from :chunk2;
-- attach new chunk
select _timescaledb_internal.chunk_attach('main_table','{"time": [1520035200000000, 1520121600000000]}'::jsonb,'n'::regclass);
              chunk_attach              
----------------------------------------
 _timescaledb_internal._hyper_1_9_chunk
(1 row)

select assert_equal(count(1),75::bigint) from main_table;
 assert_equal 
--------------
 
(1 row)


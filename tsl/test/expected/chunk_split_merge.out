\ir ../../../test/sql/include/test_utils.sql
-- This file and its contents are licensed under the Apache License 2.0.
-- Please see the included NOTICE for copyright information and
-- LICENSE-APACHE for a copy of the license.
CREATE OR REPLACE FUNCTION assert_true(
    val boolean
)
 RETURNS VOID LANGUAGE PLPGSQL IMMUTABLE AS
$BODY$
BEGIN
    IF val IS NOT TRUE THEN
        RAISE 'Assert failed';
    END IF;
END
$BODY$;
CREATE OR REPLACE FUNCTION assert_equal(
    val1 anyelement,
    val2 anyelement
)
 RETURNS VOID LANGUAGE PLPGSQL IMMUTABLE AS
$BODY$
BEGIN
    IF (val1 = val2) IS NOT TRUE THEN
        RAISE 'Assert failed: % = %',val1,val2;
    END IF;
END
$BODY$;
CREATE TABLE main_table AS
SELECT '2011-11-11 11:11:11'::timestamptz AS time, 'foo' AS device_id limit 0;
SELECT create_hypertable('main_table', 'time', chunk_time_interval => interval '12 hour', migrate_data => TRUE);
NOTICE:  adding not-null constraint to column "time"
    create_hypertable    
-------------------------
 (1,public,main_table,t)
(1 row)

ALTER TABLE main_table SET (
    timescaledb.compress,
    timescaledb.compress_segmentby = 'device_id',
    timescaledb.compress_orderby = '');
INSERT INTO main_table SELECT t, 'dev1'  FROM generate_series('2018-03-02 1:00'::TIMESTAMPTZ, '2018-03-05 3:00', '1 hour') t;
select show_chunks('main_table');
              show_chunks               
----------------------------------------
 _timescaledb_internal._hyper_1_1_chunk
 _timescaledb_internal._hyper_1_2_chunk
 _timescaledb_internal._hyper_1_3_chunk
 _timescaledb_internal._hyper_1_4_chunk
 _timescaledb_internal._hyper_1_5_chunk
 _timescaledb_internal._hyper_1_6_chunk
 _timescaledb_internal._hyper_1_7_chunk
(7 rows)

SELECT (_timescaledb_internal.show_chunk(show_chunks)).*
FROM show_chunks('main_table')
ORDER BY slices;
 chunk_id | hypertable_id |      schema_name      |    table_name    | relkind |                     slices                     
----------+---------------+-----------------------+------------------+---------+------------------------------------------------
        1 |             1 | _timescaledb_internal | _hyper_1_1_chunk | r       | {"time": [1519948800000000, 1519992000000000]}
        2 |             1 | _timescaledb_internal | _hyper_1_2_chunk | r       | {"time": [1519992000000000, 1520035200000000]}
        3 |             1 | _timescaledb_internal | _hyper_1_3_chunk | r       | {"time": [1520035200000000, 1520078400000000]}
        4 |             1 | _timescaledb_internal | _hyper_1_4_chunk | r       | {"time": [1520078400000000, 1520121600000000]}
        5 |             1 | _timescaledb_internal | _hyper_1_5_chunk | r       | {"time": [1520121600000000, 1520164800000000]}
        6 |             1 | _timescaledb_internal | _hyper_1_6_chunk | r       | {"time": [1520164800000000, 1520208000000000]}
        7 |             1 | _timescaledb_internal | _hyper_1_7_chunk | r       | {"time": [1520208000000000, 1520251200000000]}
(7 rows)

with t as (SELECT * FROM show_chunks('main_table') as t(ch) order by ch)
select
    (select ch from t limit 1 offset 2) as chunk1,
    (select ch from t limit 1 offset 3) as chunk2,
    (select ch from t limit 1 offset 4) as chunk3
    \gset
select slices as slice1 from _timescaledb_internal.show_chunk(:'chunk1') \gset
select slices as slice2 from _timescaledb_internal.show_chunk(:'chunk2') \gset
select slices as slice3 from _timescaledb_internal.show_chunk(:'chunk3') \gset
select assert_equal(count(1),75::bigint) from main_table;
 assert_equal 
--------------
 
(1 row)

CREATE OR REPLACE FUNCTION chunk_merge(hypertable REGCLASS, chunk1 REGCLASS,chunk2 REGCLASS) RETURNS REGCLASS
AS
$BODY$
DECLARE
    merged_slice  jsonb;
BEGIN
    select slices into merged_slice
        from _timescaledb_internal.chunk_detach(chunk1) as t(slices);
    select _timescaledb_internal.slice_union(hypertable,slices,merged_slice) into merged_slice
        from _timescaledb_internal.chunk_detach(chunk2) as t(slices);

    -- FIXME: earlier check for collision

    EXECUTE format('create table new_1 ( like %s )',hypertable);
    EXECUTE format('insert into new_1 select * from %s union all select * from %s',chunk1,chunk2);
    
    RAISE NOTICE 'merged_slice: %',merged_slice;

    RETURN _timescaledb_internal.chunk_attach(hypertable,merged_slice, 'new_1');
END;
$BODY$
LANGUAGE PLPGSQL VOLATILE;
\d :chunk1
            Table "_timescaledb_internal._hyper_1_3_chunk"
  Column   |           Type           | Collation | Nullable | Default 
-----------+--------------------------+-----------+----------+---------
 time      | timestamp with time zone |           | not null | 
 device_id | text                     |           |          | 
Indexes:
    "_hyper_1_3_chunk_main_table_time_idx" btree ("time" DESC)
Check constraints:
    "constraint_3" CHECK ("time" >= 'Fri Mar 02 16:00:00 2018 PST'::timestamp with time zone AND "time" < 'Sat Mar 03 04:00:00 2018 PST'::timestamp with time zone)
Inherits: main_table

\d :chunk2
            Table "_timescaledb_internal._hyper_1_4_chunk"
  Column   |           Type           | Collation | Nullable | Default 
-----------+--------------------------+-----------+----------+---------
 time      | timestamp with time zone |           | not null | 
 device_id | text                     |           |          | 
Indexes:
    "_hyper_1_4_chunk_main_table_time_idx" btree ("time" DESC)
Check constraints:
    "constraint_4" CHECK ("time" >= 'Sat Mar 03 04:00:00 2018 PST'::timestamp with time zone AND "time" < 'Sat Mar 03 16:00:00 2018 PST'::timestamp with time zone)
Inherits: main_table

select assert_equal(count(1),75::bigint) from main_table;
 assert_equal 
--------------
 
(1 row)

-- invalid range must fail
\set ON_ERROR_STOP 0
select chunk_merge('main_table', :'chunk1', :'chunk3');
NOTICE:  merged_slice: {"time": [1520035200000000, 1520164800000000]}
ERROR:  chunk creation failed due to collision
\set ON_ERROR_STOP 1
select chunk_merge('main_table', :'chunk1', :'chunk2');
NOTICE:  merged_slice: {"time": [1520035200000000, 1520121600000000]}
              chunk_merge               
----------------------------------------
 _timescaledb_internal._hyper_1_8_chunk
(1 row)

select assert_equal(count(1),75::bigint) from main_table;
 assert_equal 
--------------
 
(1 row)

\d+ main_table
                                           Table "public.main_table"
  Column   |           Type           | Collation | Nullable | Default | Storage  | Stats target | Description 
-----------+--------------------------+-----------+----------+---------+----------+--------------+-------------
 time      | timestamp with time zone |           | not null |         | plain    |              | 
 device_id | text                     |           |          |         | extended |              | 
Indexes:
    "main_table_time_idx" btree ("time" DESC)
Triggers:
    ts_insert_blocker BEFORE INSERT ON main_table FOR EACH ROW EXECUTE FUNCTION _timescaledb_internal.insert_blocker()
Child tables: _timescaledb_internal._hyper_1_1_chunk,
              _timescaledb_internal._hyper_1_2_chunk,
              _timescaledb_internal._hyper_1_5_chunk,
              _timescaledb_internal._hyper_1_6_chunk,
              _timescaledb_internal._hyper_1_7_chunk,
              _timescaledb_internal._hyper_1_8_chunk

with t as (SELECT * FROM show_chunks('main_table') as t(ch) order by ch desc)
select (select ch from t limit 1) as new_chunk \gset
select * from _timescaledb_internal.show_chunk(:'new_chunk');
 chunk_id | hypertable_id |      schema_name      |    table_name    | relkind |                     slices                     
----------+---------------+-----------------------+------------------+---------+------------------------------------------------
        8 |             1 | _timescaledb_internal | _hyper_1_8_chunk | r       | {"time": [1520035200000000, 1520121600000000]}
(1 row)

\d :new_chunk
            Table "_timescaledb_internal._hyper_1_8_chunk"
  Column   |           Type           | Collation | Nullable | Default 
-----------+--------------------------+-----------+----------+---------
 time      | timestamp with time zone |           | not null | 
 device_id | text                     |           |          | 
Indexes:
    "_hyper_1_8_chunk_main_table_time_idx" btree ("time" DESC)
Check constraints:
    "constraint_8" CHECK ("time" >= 'Fri Mar 02 16:00:00 2018 PST'::timestamp with time zone AND "time" < 'Sat Mar 03 16:00:00 2018 PST'::timestamp with time zone)
Inherits: main_table

